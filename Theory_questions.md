1) Какой самый эффективный способ конкатенации строк?

Существует несколько способов конкатенации строк в го.  
    Result := str1 + str2  
    Result := fmt.Sprint(str1, str2)  
    Result := strings.Join([]string{str1,str2}, "")  
Самым эффективным является strings.Join из-за использования strings.Builder под капотом. Основной плюс заключается в отсутствии необходимости постоянной реаллокаций памяти, так как strings.Builder не создает временные копии строк, а увеличивает внутренний буфер

2) Что такое интерфейсы, как они применяются в Go?

Интерфейсы - это абстрактный тип данных, который реализует методы без их конкретной реализации  
Type Shape interface {  
    Area() float64  
    Perimeter() float64  
}  
У нас есть разные фигуры и в большинстве из них можно рассчитать площадь и периметр, добавив в каждый методы для их вычисления мы достигнем полиморфизма - наследования общих методов для базовых структур для обеспечении единообразного способа взаимодействия с ними.

3) Чем отличаются RWMutex от Mutex?

Обычный mutex выделяет в какую часть кода может зайти только одна горутина.  
RWMutex же делится на ограничение доступа на чтение и запись, что пользователь самы выбирает, что ему ограничить.

4) Чем отличаются буферизированные и не буферизированные каналы?

Не буферизованные каналы - горутина отправляет данные в канал, она будет заблокирована до тех пор, пока другая горутина не примет данные из каналад. Это обеспечивает точное взаимодействие между горутинами и гарантирует, что данные будут доставлены и получены в правильной последовательности.  
    ch := make(chan int)  
Буферизованные каналы - позволяют отправлять данные в канал без блокировки отправляющей горутины, если буфер канала не полон. Если буфер полон, отправляющая горутина будет заблокирована до тех пор, пока другая горутина не освободит место в буфере.  
    ch := make(chan int, 3)

5) Какой размер у структуры struct{}{}?

Нуль-размерная структура - самим компилятором воспринимается как нечто без нагрузки на память

6) Есть ли в Go перегрузка методов или операторов?

Нет, я могу создавать безлимитное количество методов с одинаковыми именами, лишь бы объект слева от метода был разный (square.Area() / circle.Area() / triangle.Area())

7) В какой последовательности будут выведены элементы map[int]int?

В рандомном

8) В чем разница make и new?

Make используется для создания внутренних структур данных по типу среза, канала, мапы и возвращает их инциализированные значения. А new для создания пустых пользовательских структур и возвращает указатель на него. 

9) Сколько существует способов задать переменную типа slice или map?

var slice []int / slice := []int{} / slice := make([]int, 0)  
var m map[string]int / m := map[string]int{} / m := make(map[string]int)

10) Что выведет данная программа и почему?

    Этап 1                |     func update(p *int) {  
    a -> 1                |         b := 2  
    p -> a                |         p = &b  
                          |     }  
    Этап 2                |  
a -> 1      b -> 2        |     func main() {  
p -> a      копия p -> b  |         var (  
                          |             a = 1  
    Этап 3                |             p = &a  
    a -> 1                |         )  
    p -> a                |         fmt.Println(*p)  
                          |         update(p)  
Ответ: 1                  |         fmt.Println(*p)  
                          |     }  

11) Что выведет данная программа и почему?

   ???                              |        func main() {  
sync.WaitGroup нельзя копировать    |        wg := sync.WaitGroup{}  
при передаче в функцию              |        for i := 0; i < 5; i++ {  
                                    |            wg.Add(1)  
если передать указатель, то         |            go func(wg sync.WaitGroup, i int) {  
будут принтиться от 0 до 4          |                fmt.Println(i)  
в рандомном порядке и exit          |                wg.Done()  
                                    |            }(wg, i)  
                                    |        }  
                                    |        wg.Wait()  
                                    |        fmt.Println("exit")  
                                    |        }  

12) Что выведет данная программа и почему?

                        |       func main() {  
                        |           n := 0  
Область видимость n     |           if true {  
внутри if ограничена    |               n := 1  
                        |               n++  
Ответ: 0                |           }  
                        |           fmt.Println(n)  
                        |       }  

13)  Что выведет данная программа и почему?

  append не сработвает      |        func someAction(v []int8, b int8) {  
  v[0] = 100 сработает      |           v[0] = 100  
                            |           v = append(v, b)  
                            |        }  
Ответ: 100 2 3 4 5          |  
                            |        func main() {  
                            |           var a = []int8{1, 2, 3, 4, 5}  
                            |           someAction(a, 6)  
                            |           fmt.Println(a)  
                            |        }  

14) Что выведет данная программа и почему?

                                                        |          func main() {  
                                                        |           slice := []string{"a", "a"}  
 slice = append(slice, "a") глобально не сработает      |  
 slice[0] = "b" глобально не сработает                  |           func(slice []string) {  
 slice[1] = "b" глобально не сработает                  |              slice = append(slice, "a")  
                                                        |              slice[0] = "b"  
Ответ:    "b" "b" "a" "a" "a"                           |              slice[1] = "b"  
                                                        |              fmt.Print(slice)  
                                                        |           }(slice)  
                                                        |           fmt.Print(slice)  
                                                        |          }  
